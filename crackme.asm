# Task-13-for-Acronis
Для решения данной задачи был получен и проанализирован ассемблерный код:

1) основная часть с выводом сообщения об успешной регистрации:
push    offset String
call    sub_40137E                                       #анализ введенного логина (пункт 2)
push    eax
push    offset byte_40217E
call    sub_4013D8                                       #анализ введенного пароля (пункт 3)
add     esp, 4
pop     eax
cmp     eax, ebx                                         #сравнение преобразованного логина и преобразованного пароля
jz      short loc_40124C
  loc_40124C:
call    sub_40134D                                       #вывод сообщения об успешном вводе логина и пароля (пункт 4)
jmp     short loc_4011E6
WndProc endp

2) анализ введенного логина:
sub_40137E proc near
arg_0= dword ptr  4
mov     esi, [esp+arg_0]
push    esi
  loc_401383:                                             #посимвольная проверка логина
mov     al, [esi]
test    al, al                                            #после проверки логина переходим к подсчету суммы ord от символов (пункт 2.3 и 2.4)
jz      short loc_40139C
cmp     al, 41h                                           #сравнение с "A" - если меньше, то неверный логин (пункт 2.1)
jb      short loc_4013AC
cmp     al, 5Ah                                           #сравнение с "Z" - если не меньше, то уменьшение ord на 32 (пункт 2.2)
jnb     short loc_401394
inc     esi
jmp     short loc_401383
2.1) вывод сообщения об ошибке
  loc_4013AC:
pop     esi
push    30h             ; uType
push    offset aNoLuck  ; "No luck!"
push    offset aNoLuckThereMat ; "No luck there, mate!"
push    dword ptr [ebp+8] ; hWnd
call    MessageBoxA
2.2) уменьшение ord соответствущего символа на 20h, то есть на 32
  loc_401394:
call    sub_4013D2
inc     esi
jmp     short loc_401383
2.3) преобразование логина
  loc_40139C:
pop     esi
call    sub_4013C2                                       #подсчет суммы ord для каждого символа нового логина (пункт 2.4)
xor     edi, 5678h                                       #XOR полученной суммы и 5678
mov     eax, edi
jmp     short locret_4013C1
2.4) подсчет суммы ord каждого символа логина:
sub_4013C2 proc near
xor     edi, edi
xor     ebx, ebx
  loc_4013C6:                                            #последовательное считывание символов
mov     bl, [esi]
test    bl, bl
jz      short locret_4013D1                              #конец
add     edi, ebx                                         #суммирование
inc     esi
jmp     short loc_4013C6

3) анализ введенного пароля:
sub_4013D8 proc near
arg_0= dword ptr  4
xor     eax, eax
xor     edi, edi
xor     ebx, ebx
mov     esi, [esp+arg_0]
  loc_4013E2:                                            #последовательное считывание символов
mov     al, 0Ah
mov     bl, [esi]
test    bl, bl                                           #конец пароля, переход к XOR (пункт 3.1)
jz      short loc_4013F5
sub     bl, 30h                                          #считываение ord символа относительно '0'
imul    edi, eax                                         #преобразование ord символа в десятичную запись
add     edi, ebx
inc     esi
jmp     short loc_4013E2
3.1) XOR преобразованного пароля и 1234:
  loc_4013F5:
xor     edi, 1234h
mov     ebx, edi

4) вывод сообщения об успешном вводе:
sub_40134D proc near
push    30h             ; uType
push    offset Caption  ; "Good work!"
push    offset Text     ; "Great work, mate!\rNow try the next Cra"...
push    dword ptr [ebp+8] ; hWnd
call    MessageBoxA
retn
sub_40134D endp

Проанализировав данный ассемблерный код, получаем, что:
Логин обрезается до первых 10 символов.
Логин не принимается, если в нем есть символы меньшие "A".
Все символы в логине, не меньшие "Z" переводятся в соответствущие заглавные символы (уменьшие ord на 32).
В полученном новом логине подсчитывается сумма ord каждого символа и полученное число XOR-ится с 5678.
Пароль обрезается до первых 10 символов.
Для пароля строится десятичная запись его символов в соответствии с ord каждого символа, взятого относительно "0".
Для построенной десятичной записи для пароля считется ее XOR с 1234.
После этих преобразований полученные числа для логина и пароля сравниваются. Если они равны, то регистрация проходит успешно.

Для того, чтобы число, полученное для логина (далее число A) были равно числу, полученному из десятичной записи пароля (далее число B),
нужно чтобы B XOR 1234 = A, то есть B = A XOR 1234.
Полученное B уже может являться подходящим паролем, так как для пароля в виде десятичного числа его десятичная запись выглядит аналогино.
Чтобы построить другие пароли для данного логина, можем любую цифру из десятичной записи представить в виде буквы, у которой ord на 10 больше соответствущей цифры.
При этом соответственно уменьшив предыдущую цифру на 1.

Для данного алгоритма приведена программа crack.py, состоящая из 4 функций:
1) new_login = convert_login(login) - уменьшает ord символов, не меньших "Z" на 32 и выдает ошибку, если в лоине присутствует символ, меньший "A"
2) sumlog = sumlog(new_login) - подсчитывает сумму ord в новом логине и XOR-ит полученное число с 5678
3) passwords = create_passwords(sumlog) - предоставляет массив из возможных паролей для соответствущего sumlog по правилу, описанному выше
4) check_password(password, sumlog) - релизиует проверку пароля, аналогино той, которая приведена в описанном ассемблерном коде
1, 2 и 4 функции реализованы аналогично loc_401383, loc_40139C и sub_4013D8 соответственно.






